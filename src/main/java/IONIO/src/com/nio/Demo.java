package IONIO.src.com.nio;

public class Demo {
	// 区别
	// IO与NIO的主要区别是数据的打包和传输方式,IO是通过流,而NIO是通过块
	// 面向流的IO系统,一次一个字节地处理,为流式数据创建过滤器比较简单,链接几个过滤器以便每个过滤器只负责处理单个复杂处理机制的一部分
	// 面向流的IO系统的缺点是:慢

	// 面向块的数据处理每次都产生或消费一个块,速度上会快很多,但是缺少了流处理的一些优雅性和简洁性
	// 现在io中的一些包也与NIO有一定的集成,有些类包含以块形式读取数据的方法
	// 可以很容易地使用块IO一次一个字节地处理数据

	// 通道
	// Channel是对原IO中流的模拟.到任何地方或者来自任何地方的数据都必须经过Channel(通道)
	// Buffer实质上是一个容器对象,发送给一个通道的所有对象都必须先放到缓冲区中,同样的,读取也要读取到缓冲区中.
	// 永远不会直接向通道中写数据,也不会从通道中直接读数据,而是先读/写到缓冲区,再从缓冲区读取

	// 通道与流的不同是:通道是双向的,流只在一个方向上移动;通道可以用于读/写/同时读写;
	// 通道可以比流更好地反映操作系统的真实情况,特别是在UNIX模型中,底层操作系统通道是双向的.

	// 状态变量position limit capacity,跟踪缓冲区的状态和数据
	// 读数据:position指定下一个字节将放到哪个位置,跟踪已经写了多少数据
	// 写数据:position跟踪缓冲区的数据,指定下一个字节来自数组的哪一个元素
	// limit:还有多少数据需要取出或或还有多少空间可以读入
	// position总是小于或等于limit

	// capacity表示缓冲区的总容量,指定底层数组大小或者准许我们使用的底层数组的容量
	// limit不会大于capacity

	// 初始时用于写入:
	// position=0;limit=capacity=arr.length(不是length-1),
	// 每次写入字节后position指向下一个可写入位置,limit在写入过程中不变

	// flip方法
	// limit=position;position=0;
	// position指示下一个可读取的位置,limit在读取过程中不变

	// clear方法,在读取完后
	// 将buffer指示为读入缓冲区状态
	// position=0;limit=capacity;
	// 同初始时状态.

}
